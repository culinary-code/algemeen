# General Introduction

Welcome to the Culinary Code app. Culinary Code helps users efficiently manage meals and groceries with a user-friendly interface. This repo provides you with the necessary tools to do two out of our three intended uses:

- [ ] Utilize our own backend api with a small fee to utilize the services
- [x] Spin up your own backend api service and use your own openAI key for all AI services
- [x] Spin up your own backend api service, spin up a local LLM to replace the openAI services (success not guaranteed)   

To see what features the application currently has, visit [[Features]]

To see what features are currently planned, visit [[Planned_Features]]

To help develop these features, look at [[How_To]]


# Features

The application currently has the following features:

- Logging into a Keycloak account
- Registering a new Keycloak account
- Changing the username of the Keycloak account
- Browsing recipes based on recipe names
- Viewing recipes in detail
- Adding reviews to recipes
- Creating new recipes based on a chatgpt prompt: supported identifiers include recipe name, ingredients, cooking time, difficulty, preferences

# Planned Features

The application currently has the following features planned: 

- Browsing recipes based on ingredients, cooking time, difficulty, preferences
- Adding recipes to a favorites list
- Adding recipes to a meal planner
- Viewing said meal planner
- View a grocery list based on planned meals
- Add items and ingredients to the grocery list
- Managing Account settings: preferences that automatically get added to prompts, family size
- .... 

# Keycloak

- ## Set up

  When you have the docker image running locally or in the cloud, go to the address provided in the docker compose file or the url in the cloud. You should see a login screen.
  1. Log in as admin. In the provided docker file the name and password are both admin, but it is recommended to change those values
  2. On the top left you should see a dropdown menu that is currently set to the master realm
  3. Click on that dropdown menu and create a new realm
  4. In the json input field, select import from file and select the provided realm-export.json file in the location where you downloaded this project
  5. You should now have a new realm, you can change the name of this realm for security purposes but be aware that you will need to change environment variables. see [[Environment_Variables]]

- ## Necessary Users
  1. Go to the user tab, this should be visible on the left hand side
  2. Create a new user. This will become the admin user with rights to create new accounts.
  3. After creation of the user, go to the credentials tab of that user (at the top) and create a new password. Set "temporary" to off.
  4. Go to the role management tab of the user (at the top)
  5. Give the user the following roles:
        - realm-admin
        - manage-account-links
        - manage-account
        - view-profile
  6. The user should be all set up

# Deploying to Azure

- ## GPT
For the deployment of the GPT model, we make use of Azure OpenAI Service. You can set up an OpenAI service on Azure using the following link:

https://portal.azure.com/#view/Microsoft_Azure_ProjectOxford/CognitiveServicesHub/~/OpenAI

We used the GPT-4o Mini model for this project. A breakdown of why we chose this model can be found at [[Recommended_LLM_Model]].

Once the service is set up, you can get the API key and endpoint from the Azure portal and set them as environment variables in the backend application.

- ## Image generator
For recipe image generation, we make use of a DALL-E 3 deployment on Azure. You can set up a DALL-E 3 model deployment on Azure OpenAI Studio.

Once the service is set up, you can get the API key and endpoint from the Azure portal and set them as environment variables in the backend application.

- ## Blob storage
Azure Blob storage is used to store images generated by the DALL-E 3 model. You can set up a Blob storage on Azure using the following link: [https://portal.azure.com/#create/Microsoft.StorageAccount](https://portal.azure.com/#create/Microsoft.StorageAccount)

Once the Blob storage is set up, you can get the connection string and container name from the Azure portal and set them as environment variables in the backend application.

Ensure that the MIME type of the images generated by the DALL-E 3 model is set to "image/png" before uploading them to the Blob storage.

Also ensure you configure the CORS settings of the Blob storage to allow requests from the backend application. As well as the public access level of the container to allow public access to the images.

- ## Database
Azure PostgreSQL database - Flexible server

You can set up a PostgreSQL database on Azure using the following link: [https://portal.azure.com/#browse/Microsoft.DBforPostgreSQL%2FflexibleServers](https://portal.azure.com/#create/Microsoft.PostgreSQLFlexibleServer)

Configure the specifications based on your development or production needs.

Create a new user role on the database with restricted permissions to use from the backend application.

- ## Keycloak
When you set up Keycloak, you can export the currently configured realm into a json file, check out the documentation around exporting here: [Importing and Exporting Realms](https://www.keycloak.org/server/importExport)

Then you can make a Dockerfile where you pull in the base Keycloak image and add your own ENTRYPOINT command where you set up import realm.
```Dockerfile
FROM quay.io/keycloak/keycloak:25.0.5

RUN mkdir -p /opt/keycloak/data/import
COPY ./realm-export.json /opt/keycloak/data/import

EXPOSE 8080

ENTRYPOINT ["/opt/keycloak/bin/kc.sh", "-v", "start-dev", "--import-realm"]
```

Then you can build and push the Docker image to Docker hub for example.
```bash
docker build -t steffenvochten/culinarycode_idp:latest .  # tag latest so you don't have to delete and recreate the container instance on Azure for image changes
docker push steffenvochten/culinarycode_idp:latest
```

Now on Azure you can set up a Container Instance which will pull and run your Docker image in the cloud.

If you tag your docker image with latest, you can push changes to the image to docker hub, without having to delete and recreate the Container Instance, since its settings can't be changed.

Set up a Container Instance on Azure using the following link https://portal.azure.com/#browse/Microsoft.ContainerInstance%2FcontainerGroups

- ## Backend

To deploy the app on Azure we make use of the Azure App Service.

To create a Web App on Azure, use this link: https://portal.azure.com/#create/Microsoft.WebSite

The runtime stack the backend application uses is .NET 8. The target operating system is Linux.

Once the Web App is set up on Azure, we can push our backend application to this Web App.

First, navigate to the application's root folder, then follow these steps:
```bash
cd .\WEBAPI\
dotnet publish -c Release -r linux-x64 --self-contained false -o ./publish
cd .\publish\
zip -r ../culinarycode.zip .
az webapp deployment source config-zip --resource-group rg-stage24-webchefs --name culinarycode --src culinarycode.zip
```

You can view application logs using this command:
```bash
az webapp log tail --name culinarycode --resource-group rg-stage24-webchefs
```

Finally ensure that all the environment variables are properly set up in the Web App settings on Azure, ensure that you point the environment variables for the database and Keycloak container URLs point to the proper Azure service URLs.


# Running everything locally

## Recommended LLM Model

After extensive testing, we recommend using the GPT-4o Mini model (version: 2024-07-18) for this project. This model has consistently delivered reliable and accurate results, meeting our specific requirements.

While we also tested GPT-3.5 Turbo, we found its reliability to be significantly lower, particularly in non-English languages. Since our development and testing focus on a Dutch-speaking user base, the GPT-4o Mini model proved far superior in handling these language-specific needs.

Additionally, we tested several local LLMs, but found that the output from smaller models was not reliable, with significant inconsistencies in performance. Larger models might offer better reliability, but they require significantly higher computational resources. Running them efficiently would demand high-end hardware, which may not be practical for all setups.

For users opting for local hosting, we recommend using an OpenAI model as the preferred option. Users can easily add their own OpenAI API key via the mobile app, enabling them to leverage the full reliability of OpenAI's models. The local LLM should only be used as a last resort, particularly due to the lower reliability and performance issues we encountered.


# Environment variables

- ## Frontend
  - KEYCLOAK_BASE_URL: Start of the Keycloak url appended before any calls made to Keycloak. Example for local development: "http://localhost:8180"
  - KEYCLOAK_CLIENT_ID: Name of your Keycloak client. Example: "flutter-app"
  - KEYCLOAK_REALM: Name of your Keycloak realm. Example: "culinary-code-dev-realm"
  - BACKEND_BASE_URL: Start of the backend url appended before any calls made to the backend api endpoints. Example for local development: "https://localhost:7098"
  
- ## Backend
  - AZURE_OPENAI_API_KEY: OpenAI api key for the openAI services running in Azure.
  - AZURE_OPENAI_ENDPOINT: Start of the azure openAI services url appended before any call made to these services.
  - AZURE_STORAGE_CONNECTION_STRING: Connection string for the blob storage running in Azure.
  - AZURE_STORAGE_CONTAINER_NAME: Container name for the blob storage running in Azure.
  - KEYCLOAK_BASE_URL: Start of the Keycloak url appended before any calls made to Keycloak. Example for local development: "http://localhost:8180"
  - KEYCLOAK_CLIENT_ID: Name of your Keycloak client. Example: "flutter-app"
  - KEYCLOAK_REALM: Name of your Keycloak realm. Example: "culinary-code-dev-realm"
  - KEYCLOAK_ADMIN_USERNAME: name of the admin with rights to create new accounts.
  - KEYCLOAK_ADMIN_PASSWORD: name of the password for the admin account mentioned above.

# Frontend

# Backend

# Roadmap

# Known Bugs

# Licences
  - Apache2.0
  - Moq diff license

# How to 

- ## Set the project up

- ## Pull Request

- ## Report Bugs

- ## Ask questions
